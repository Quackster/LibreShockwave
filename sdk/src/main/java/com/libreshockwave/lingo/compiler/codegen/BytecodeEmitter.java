package com.libreshockwave.lingo.compiler.codegen;

import com.libreshockwave.lingo.Opcode;

import java.io.ByteArrayOutputStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Emitter for Lingo bytecode instructions.
 * Handles encoding of opcodes with variable-length arguments and
 * manages forward references for jump targets.
 */
public class BytecodeEmitter {

    private final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
    private final List<PendingJump> pendingJumps = new ArrayList<>();
    private final Map<String, Integer> labels = new HashMap<>();

    /**
     * Pending jump that needs to be patched when target is known.
     */
    private record PendingJump(int offset, int argSize, String label) {}

    /**
     * Get current bytecode offset.
     */
    public int getOffset() {
        return buffer.size();
    }

    /**
     * Get the generated bytecode.
     */
    public byte[] getBytecode() {
        return buffer.toByteArray();
    }

    /**
     * Reset the emitter for a new handler.
     */
    public void reset() {
        buffer.reset();
        pendingJumps.clear();
        labels.clear();
    }

    // --- Single-byte opcodes (no arguments) ---

    public void emit(Opcode opcode) {
        if (opcode.isMultiByte()) {
            throw new IllegalArgumentException("Opcode " + opcode + " requires an argument");
        }
        buffer.write(opcode.getCode());
    }

    public void emitRet() { emit(Opcode.RET); }
    public void emitRetFactory() { emit(Opcode.RET_FACTORY); }
    public void emitPushZero() { emit(Opcode.PUSH_ZERO); }
    public void emitMul() { emit(Opcode.MUL); }
    public void emitAdd() { emit(Opcode.ADD); }
    public void emitSub() { emit(Opcode.SUB); }
    public void emitDiv() { emit(Opcode.DIV); }
    public void emitMod() { emit(Opcode.MOD); }
    public void emitInv() { emit(Opcode.INV); }
    public void emitJoinStr() { emit(Opcode.JOIN_STR); }
    public void emitJoinPadStr() { emit(Opcode.JOIN_PAD_STR); }
    public void emitLt() { emit(Opcode.LT); }
    public void emitLtEq() { emit(Opcode.LT_EQ); }
    public void emitNtEq() { emit(Opcode.NT_EQ); }
    public void emitEq() { emit(Opcode.EQ); }
    public void emitGt() { emit(Opcode.GT); }
    public void emitGtEq() { emit(Opcode.GT_EQ); }
    public void emitAnd() { emit(Opcode.AND); }
    public void emitOr() { emit(Opcode.OR); }
    public void emitNot() { emit(Opcode.NOT); }
    public void emitContainsStr() { emit(Opcode.CONTAINS_STR); }
    public void emitContains0Str() { emit(Opcode.CONTAINS_0_STR); }
    public void emitGetChunk() { emit(Opcode.GET_CHUNK); }
    public void emitHiliteChunk() { emit(Opcode.HILITE_CHUNK); }
    public void emitOntoSpr() { emit(Opcode.ONTO_SPR); }
    public void emitIntoSpr() { emit(Opcode.INTO_SPR); }
    public void emitGetField() { emit(Opcode.GET_FIELD); }
    public void emitStartTell() { emit(Opcode.START_TELL); }
    public void emitEndTell() { emit(Opcode.END_TELL); }
    public void emitPushList() { emit(Opcode.PUSH_LIST); }
    public void emitPushPropList() { emit(Opcode.PUSH_PROP_LIST); }
    public void emitSwap() { emit(Opcode.SWAP); }

    // --- Multi-byte opcodes (with arguments) ---

    /**
     * Emit a multi-byte opcode with argument.
     * Automatically selects the appropriate encoding based on argument size.
     */
    public void emit(Opcode opcode, int argument) {
        if (opcode.isSingleByte()) {
            throw new IllegalArgumentException("Opcode " + opcode + " does not take an argument");
        }

        int baseCode = opcode.getCode();

        // Determine argument size needed
        if (argument >= -128 && argument <= 255 && canUseOneByte(opcode)) {
            // 1-byte argument: opcode 0x40-0x7F
            buffer.write(baseCode);
            buffer.write(argument & 0xFF);
        } else if (argument >= -32768 && argument <= 65535 && canUseTwoBytes(opcode)) {
            // 2-byte argument: opcode 0x80-0xBF
            buffer.write(baseCode + 0x40);
            buffer.write((argument >> 8) & 0xFF);
            buffer.write(argument & 0xFF);
        } else {
            // 4-byte argument: opcode 0xC0-0xFF
            buffer.write(baseCode + 0x80);
            buffer.write((argument >> 24) & 0xFF);
            buffer.write((argument >> 16) & 0xFF);
            buffer.write((argument >> 8) & 0xFF);
            buffer.write(argument & 0xFF);
        }
    }

    private boolean canUseOneByte(Opcode opcode) {
        // PUSH_INT16 and PUSH_INT32 need at least 2 bytes
        return opcode != Opcode.PUSH_INT16 && opcode != Opcode.PUSH_INT32 && opcode != Opcode.PUSH_FLOAT32;
    }

    private boolean canUseTwoBytes(Opcode opcode) {
        // PUSH_INT32 and PUSH_FLOAT32 need 4 bytes
        return opcode != Opcode.PUSH_INT32 && opcode != Opcode.PUSH_FLOAT32;
    }

    // Convenience methods for common opcodes

    public void emitPushInt(int value) {
        if (value == 0) {
            emitPushZero();
        } else if (value >= -128 && value <= 127) {
            emit(Opcode.PUSH_INT8, value);
        } else if (value >= -32768 && value <= 32767) {
            // Use 2-byte encoding
            buffer.write(Opcode.PUSH_INT8.getCode() + 0x40); // 0x6E = PUSH_INT16
            buffer.write((value >> 8) & 0xFF);
            buffer.write(value & 0xFF);
        } else {
            // Use 4-byte encoding
            buffer.write(Opcode.PUSH_INT8.getCode() + 0x80); // 0x6F = PUSH_INT32
            buffer.write((value >> 24) & 0xFF);
            buffer.write((value >> 16) & 0xFF);
            buffer.write((value >> 8) & 0xFF);
            buffer.write(value & 0xFF);
        }
    }

    public void emitPushFloat(float value) {
        int bits = Float.floatToIntBits(value);
        buffer.write(Opcode.PUSH_FLOAT32.getCode() + 0x80); // Always 4 bytes
        buffer.write((bits >> 24) & 0xFF);
        buffer.write((bits >> 16) & 0xFF);
        buffer.write((bits >> 8) & 0xFF);
        buffer.write(bits & 0xFF);
    }

    public void emitPushCons(int literalIndex) {
        emit(Opcode.PUSH_CONS, literalIndex);
    }

    public void emitPushSymb(int nameId) {
        emit(Opcode.PUSH_SYMB, nameId);
    }

    public void emitPushArgList(int argCount) {
        emit(Opcode.PUSH_ARG_LIST, argCount);
    }

    public void emitPushArgListNoRet(int argCount) {
        emit(Opcode.PUSH_ARG_LIST_NO_RET, argCount);
    }

    public void emitGetGlobal(int index) {
        emit(Opcode.GET_GLOBAL, index);
    }

    public void emitSetGlobal(int index) {
        emit(Opcode.SET_GLOBAL, index);
    }

    public void emitGetProp(int index) {
        emit(Opcode.GET_PROP, index);
    }

    public void emitSetProp(int index) {
        emit(Opcode.SET_PROP, index);
    }

    public void emitGetParam(int index) {
        emit(Opcode.GET_PARAM, index);
    }

    public void emitSetParam(int index) {
        emit(Opcode.SET_PARAM, index);
    }

    public void emitGetLocal(int index) {
        emit(Opcode.GET_LOCAL, index);
    }

    public void emitSetLocal(int index) {
        emit(Opcode.SET_LOCAL, index);
    }

    public void emitExtCall(int nameId) {
        emit(Opcode.EXT_CALL, nameId);
    }

    public void emitLocalCall(int handlerIndex) {
        emit(Opcode.LOCAL_CALL, handlerIndex);
    }

    public void emitObjCall(int nameId) {
        emit(Opcode.OBJ_CALL, nameId);
    }

    public void emitTheBuiltin(int builtinId) {
        emit(Opcode.THE_BUILTIN, builtinId);
    }

    public void emitGetMovieProp(int nameId) {
        emit(Opcode.GET_MOVIE_PROP, nameId);
    }

    public void emitSetMovieProp(int nameId) {
        emit(Opcode.SET_MOVIE_PROP, nameId);
    }

    public void emitGetObjProp(int nameId) {
        emit(Opcode.GET_OBJ_PROP, nameId);
    }

    public void emitSetObjProp(int nameId) {
        emit(Opcode.SET_OBJ_PROP, nameId);
    }

    public void emitGet(int type) {
        emit(Opcode.GET, type);
    }

    public void emitSet(int type) {
        emit(Opcode.SET, type);
    }

    public void emitPut(int type) {
        emit(Opcode.PUT, type);
    }

    public void emitPutChunk(int type) {
        emit(Opcode.PUT_CHUNK, type);
    }

    public void emitDeleteChunk(int type) {
        emit(Opcode.DELETE_CHUNK, type);
    }

    public void emitPeek(int offset) {
        emit(Opcode.PEEK, offset);
    }

    public void emitPop(int count) {
        emit(Opcode.POP, count);
    }

    public void emitNewObj(int nameId) {
        emit(Opcode.NEW_OBJ, nameId);
    }

    // --- Jump instructions ---

    /**
     * Define a label at the current offset.
     */
    public void defineLabel(String label) {
        labels.put(label, getOffset());
    }

    /**
     * Emit a jump to a label. If label is not yet defined, creates a pending jump.
     */
    public void emitJmp(String label) {
        emitJumpToLabel(Opcode.JMP, label);
    }

    /**
     * Emit a conditional jump (jump if zero/false).
     */
    public void emitJmpIfZ(String label) {
        emitJumpToLabel(Opcode.JMP_IF_Z, label);
    }

    /**
     * Emit an end repeat (jump back to loop start).
     */
    public void emitEndRepeat(String label) {
        emitJumpToLabel(Opcode.END_REPEAT, label);
    }

    /**
     * Emit a jump with a known offset (relative or absolute based on context).
     */
    public void emitJmp(int offset) {
        emit(Opcode.JMP, offset);
    }

    public void emitJmpIfZ(int offset) {
        emit(Opcode.JMP_IF_Z, offset);
    }

    public void emitEndRepeat(int offset) {
        emit(Opcode.END_REPEAT, offset);
    }

    private void emitJumpToLabel(Opcode opcode, String label) {
        Integer target = labels.get(label);
        if (target != null) {
            // Label already defined - emit direct jump
            emit(opcode, target);
        } else {
            // Forward reference - emit placeholder and record for patching
            int jumpOffset = getOffset();
            // Reserve space for 2-byte argument (most common case)
            buffer.write(opcode.getCode() + 0x40);
            buffer.write(0);
            buffer.write(0);
            pendingJumps.add(new PendingJump(jumpOffset, 2, label));
        }
    }

    /**
     * Resolve all pending jumps. Call after all code is emitted.
     */
    public byte[] resolveJumps() {
        byte[] bytecode = buffer.toByteArray();

        for (PendingJump jump : pendingJumps) {
            Integer target = labels.get(jump.label);
            if (target == null) {
                throw new IllegalStateException("Undefined label: " + jump.label);
            }

            // Patch the jump target
            if (jump.argSize == 2) {
                bytecode[jump.offset + 1] = (byte) ((target >> 8) & 0xFF);
                bytecode[jump.offset + 2] = (byte) (target & 0xFF);
            } else if (jump.argSize == 4) {
                bytecode[jump.offset + 1] = (byte) ((target >> 24) & 0xFF);
                bytecode[jump.offset + 2] = (byte) ((target >> 16) & 0xFF);
                bytecode[jump.offset + 3] = (byte) ((target >> 8) & 0xFF);
                bytecode[jump.offset + 4] = (byte) (target & 0xFF);
            }
        }

        return bytecode;
    }

    /**
     * Get the current label definitions.
     */
    public Map<String, Integer> getLabels() {
        return new HashMap<>(labels);
    }

    /**
     * Generate a unique label name.
     */
    private int labelCounter = 0;

    public String generateLabel(String prefix) {
        return prefix + "_" + (labelCounter++);
    }
}
